.
./.git
./.git/hooks
./.git/info
./.git/logs
./.git/logs/refs
./.git/logs/refs/heads
./.git/logs/refs/remotes
./.git/logs/refs/remotes/origin
./.git/objects
./.git/objects/04
./.git/objects/16
./.git/objects/2f
./.git/objects/38
./.git/objects/54
./.git/objects/55
./.git/objects/5f
./.git/objects/60
./.git/objects/79
./.git/objects/7f
./.git/objects/af
./.git/objects/dc
./.git/objects/ea
./.git/objects/info
./.git/objects/pack
./.git/refs
./.git/refs/heads
./.git/refs/remotes
./.git/refs/remotes/origin
./.git/refs/tags
./scripts
./scripts/bootable-usb
./scripts/bootable-usb/modules
./scripts/determine-arch-ver
./scripts/install
./scripts/setup-root-ca


--- FILE CONTENTS ---




### FILE: ./install.sh

#!/bin/bash

# Mango Linux Configuration - Main Installation Script
# This script serves as the central entrypoint for all Mango Linux configuration options

# Colors for formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to check if script is run with sufficient permissions
check_permissions() {
    if [[ $1 == "root" && "$(id -u)" -ne 0 ]]; then
        echo -e "${RED}This option requires root privileges. Please run with sudo.${NC}"
        exit 1
    fi
}

# Function to make scripts executable
make_executable() {
    local script_path="$1"
    if [ -f "$script_path" ]; then
        chmod +x "$script_path"
    else
        echo -e "${RED}Script not found: $script_path${NC}"
        exit 1
    fi
}

# Display ASCII art header
display_header() {
    clear
    echo -e "${GREEN}"
    echo "   __  ___                            __    _                  "
    echo "  /  |/  /___ _____  ____ _____     / /   (_)___  __  ___  __ "
    echo " / /|_/ / __ \`/ __ \/ __ \`/ __ \   / /   / / __ \/ / / / |/_/ "
    echo "/ /  / / /_/ / / / / /_/ / /_/ /  / /___/ / / / / /_/ />  <   "
    echo "/_/  /_/\__,_/_/ /_/\__, /\____/  /_____/_/_/ /_/\__,_/_/|_|   "
    echo "                   /____/                                      "
    echo -e "${NC}"
    echo -e "${YELLOW}Mango Linux Configuration - Installation Manager${NC}"
    echo -e "${BLUE}A repository for automating the setup and configuration of Arch Linux${NC}"
    echo "-----------------------------------------------------------------------"
}

# Function to run system discovery script
run_system_discovery() {
    echo -e "\n${BLUE}=== System Discovery ===${NC}"
    echo -e "This will analyze your system and recommend the appropriate Arch Linux version.\n"

    local os_type="$(uname -s)"
    if [[ "$os_type" == "Linux" ]]; then
        make_executable "scripts/determine-arch-ver/linux-os-discovery-updated.sh"
        ./scripts/determine-arch-ver/linux-os-discovery-updated.sh
    elif [[ "$os_type" == "MINGW"* ]] || [[ "$os_type" == "MSYS"* ]] || [[ "$os_type" == "CYGWIN"* ]]; then
        echo -e "${YELLOW}Windows detected. Running PowerShell script...${NC}"
        powershell.exe -ExecutionPolicy Bypass -File scripts/determine-arch-ver/windows-os-discovery-updated.ps1
    else
        echo -e "${RED}Unsupported operating system: $os_type${NC}"
        echo -e "${YELLOW}Please manually run one of the following scripts:${NC}"
        echo -e "- scripts/determine-arch-ver/linux-os-discovery-updated.sh (for Linux)"
        echo -e "- scripts/determine-arch-ver/windows-os-discovery-updated.ps1 (for Windows)"
    fi
}

# Function to create bootable USB
create_bootable_usb() {
    echo -e "\n${BLUE}=== Create Bootable USB ===${NC}"
    echo -e "This will create a bootable Arch Linux USB drive.\n"
    
    check_permissions "root"
    make_executable "scripts/bootable-usb/arch-usb-creator.sh"
    
    ./scripts/bootable-usb/arch-usb-creator.sh
}

# Function to install Arch Linux
install_arch_linux() {
    echo -e "\n${BLUE}=== Install Arch Linux ===${NC}"
    echo -e "This will install Arch Linux with a development environment.\n"
    
    check_permissions "root"
    make_executable "scripts/install/arch-install-script.sh"
    
    echo -e "${YELLOW}WARNING: This script should be run from the Arch Linux live environment.${NC}"
    read -p "Are you currently booted into the Arch Linux live environment? (y/n): " confirm
    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
        ./scripts/install/arch-install-script.sh
    else
        echo -e "${RED}Installation aborted. Please boot into the Arch Linux live environment first.${NC}"
    fi
}

# Function to setup root CA
setup_root_ca() {
    echo -e "\n${BLUE}=== Setup Root CA ===${NC}"
    echo -e "This will set up a Root Certificate Authority on YubiKeys.\n"
    
    make_executable "scripts/setup-root-ca/root-ca-setup.sh"
    
    # Check if required tools are installed
    if ! command -v ykman &>/dev/null || ! command -v openssl &>/dev/null; then
        echo -e "${RED}Required tools not found. Please install 'yubikey-manager' and 'openssl'.${NC}"
        read -p "Do you want to install the required packages? (y/n): " install_confirm
        if [[ "$install_confirm" == "y" || "$install_confirm" == "Y" ]]; then
            # Detect package manager and install
            if command -v apt &>/dev/null; then
                sudo apt update && sudo apt install -y yubikey-manager openssl
            elif command -v dnf &>/dev/null; then
                sudo dnf install -y yubikey-manager openssl
            elif command -v pacman &>/dev/null; then
                sudo pacman -S --noconfirm yubikey-manager openssl
            else
                echo -e "${RED}Unable to install packages. Please install manually.${NC}"
                exit 1
            fi
        else
            echo -e "${YELLOW}Aborting setup. Please install the required tools manually.${NC}"
            exit 1
        fi
    fi
    
    ./scripts/setup-root-ca/root-ca-setup.sh
}

# Main function
main() {
    display_header
    
    echo -e "\nPlease select an option:"
    echo -e "1) ${BLUE}System Discovery${NC} - Determine appropriate Arch Linux version"
    echo -e "2) ${BLUE}Create Bootable USB${NC} - Create bootable Arch Linux USB drive"
    echo -e "3) ${BLUE}Install Arch Linux${NC} - Full Arch Linux installation"
    echo -e "4) ${BLUE}Setup Root CA${NC} - Set up a Root Certificate Authority"
    echo -e "0) ${BLUE}Exit${NC}"
    
    read -p "Enter your choice [0-4]: " choice
    
    case $choice in
        1)
            run_system_discovery
            ;;
        2)
            create_bootable_usb
            ;;
        3)
            install_arch_linux
            ;;
        4)
            setup_root_ca
            ;;
        0)
            echo -e "${GREEN}Exiting. Goodbye!${NC}"
            exit 0
            ;;
        *)
            echo -e "${RED}Invalid option. Please try again.${NC}"
            main
            ;;
    esac
    
    # Ask if user wants to return to main menu
    echo -e "\n"
    read -p "Return to main menu? (y/n): " return_menu
    if [[ "$return_menu" == "y" || "$return_menu" == "Y" ]]; then
        main
    else
        echo -e "${GREEN}Exiting. Goodbye!${NC}"
    fi
}

# Run main function
main





### FILE: ./README.md

# Mango Linux Configuration

A repository for automating the setup and configuration of Arch Linux with custom tools, settings, and configurations.

## Quick Start

The easiest way to get started is to use the main installation script:

```bash
# Make the script executable (first-time only)
chmod +x install.sh

# Run the installation script
./install.sh
```

The installation script provides a menu to access all available tools:
- System Discovery - Determine appropriate Arch Linux version for your hardware
- Create Bootable USB - Create a bootable Arch Linux USB drive
- Install Arch Linux - Full Arch Linux installation
- Setup Root CA - Set up a Root Certificate Authority on YubiKeys

## Repository Structure

```
.
├── README.md
├── install.sh       # Main installation script
├── config
│   ├── git
│   ├── intellij
│   ├── kde
│   ├── neovim
│   ├── starship
│   └── zsh
├── docs
│   ├── customization
│   ├── installation
│   └── troubleshooting
├── dotfiles
└── scripts
    ├── bootable-usb
    │   ├── README.md                # Documentation for USB creation scripts
    │   └── arch-usb-creator.sh      # Script for creating bootable Arch Linux USB drives
    ├── determine-arch-ver
    │   ├── linux-os-discovery-updated.sh    # System info discovery for Linux
    │   ├── README.md                # Detailed instructions for discovery scripts
    │   └── windows-os-discovery-updated.ps1 # System info discovery for Windows
    ├── install
    │   ├── README.md                # Documentation for Arch Linux installation script
    │   └── arch-install-script.sh   # Comprehensive Arch Linux installation script
    ├── post-install
    ├── setup-root-ca
    │   └── root-ca-setup.sh
    └── utils
```

## Individual Script Usage

If you prefer to run individual scripts directly, you can use the following commands:

### System Discovery Scripts

Determine the appropriate Arch Linux version to install based on your hardware specifications:

#### For Linux Users

```bash
# Make the script executable (first-time only)
chmod +x scripts/determine-arch-ver/linux-os-discovery-updated.sh

# Run the discovery script
./scripts/determine-arch-ver/linux-os-discovery-updated.sh
```

#### For Windows Users

```powershell
# Open PowerShell as Administrator
# You may need to change execution policy
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process

# Run the discovery script
.\scripts\determine-arch-ver\windows-os-discovery-updated.ps1
```

These scripts analyze your system hardware and provide:
- An immediate recommendation for which Arch Linux version to install
- Custom installation notes specific to your hardware

For detailed usage and requirements, refer to `scripts/determine-arch-ver/README.md`.

### Bootable USB Creation

Create a bootable Arch Linux USB drive:

```bash
# Make the script executable (first-time only)
chmod +x scripts/bootable-usb/arch-usb-creator.sh

# Run the USB creator
sudo ./scripts/bootable-usb/arch-usb-creator.sh
```

Key features:
- Select specific Arch Linux version
- Choose CPU architecture (x86_64, ARM64, ARM32)
- Automatic ISO download and verification
- Detailed system compatibility options

⚠️ **Warning**: The script will ERASE all data on the selected USB drive.

For detailed usage and requirements, refer to `scripts/bootable-usb/README.md`.

### Installation Script

A comprehensive Arch Linux installation script is provided to automate the setup of a development environment.

```bash
# Make the script executable (first-time only)
chmod +x scripts/install/arch-install-script.sh

# Run the installation script
sudo ./scripts/install/arch-install-script.sh
```

### Root CA Setup

Set up a Root Certificate Authority with YubiKey support:

```bash
# Make the script executable (first-time only)
chmod +x scripts/setup-root-ca/root-ca-setup.sh

# Run the setup script
./scripts/setup-root-ca/root-ca-setup.sh
```

## Future Enhancements

This repository will continue to be expanded to include:
- More comprehensive system configuration scripts
- Enhanced dotfiles and configuration management
- Additional system utility scripts
- Expanded support for development environments
- Improved hardware detection and compatibility scripts

## Contributing

Feel free to submit pull requests or suggest improvements to these scripts.

## License

This project is open source and available under the [MIT License](LICENSE).





### FILE: ./scripts/bootable-usb/arch-usb-creator.sh

#!/bin/bash

# Arch Linux Bootable USB Creator
# This script helps create a bootable USB drive for Arch Linux installation
# and includes the Mango Linux Configuration repository content

# Colors for formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# MIT Mirror URL
MIT_MIRROR="https://mirrors.mit.edu/archlinux/iso/"

# Hardcoded Arch version - can be easily changed here
ARCH_VERSION="2025.01.01"

# Function to check if script is run with sudo
check_sudo() {
    if [ "$EUID" -ne 0 ]; then
        echo -e "${RED}Please run this script with sudo or as root${NC}"
        exit 1
    fi
}

# Function to check if required tools are installed
check_dependencies() {
    local deps=("wget" "dd" "grep" "rsync")
    local missing=()

    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing+=("$dep")
        fi
    done

    if [ ${#missing[@]} -ne 0 ]; then
        echo -e "${RED}The following dependencies are missing:${NC}"
        printf "  %s\n" "${missing[@]}"
        echo -e "${YELLOW}Please install them using your package manager and try again.${NC}"
        exit 1
    fi
}

# Function to list available USB drives
list_usb_drives() {
    echo -e "${YELLOW}Available USB Drives:${NC}"
    lsblk -do NAME,SIZE,TYPE,MOUNTPOINT | grep -E 'sd[b-z]|usb'
}

# Function to download Arch Linux ISO from MIT mirror
download_iso() {
    local version="$ARCH_VERSION"
    local iso_url="${MIT_MIRROR}${version}/archlinux-${version}-x86_64.iso"
    local iso_filename="archlinux-${version}-x86_64.iso"

    echo -e "${GREEN}Downloading Arch Linux ${version} from MIT mirror...${NC}"
    echo -e "${YELLOW}URL: ${iso_url}${NC}"
    
    # Download with wget, showing progress
    wget --progress=bar:force -O "${iso_filename}" "${iso_url}"

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Download complete: ${iso_filename}${NC}"
        
        # Verify download by checking file size
        local file_size=$(stat -c %s "${iso_filename}")
        if [ "$file_size" -lt 700000000 ]; then  # ISO should be at least ~700MB
            echo -e "${RED}Warning: Downloaded file seems too small (${file_size} bytes).${NC}"
            echo -e "${YELLOW}The download might be incomplete or corrupted.${NC}"
            read -p "Do you want to continue anyway? (yes/no): " continue_anyway
            if [[ "$continue_anyway" != "yes" ]]; then
                echo -e "${RED}Operation cancelled.${NC}"
                exit 1
            fi
        fi
    else
        echo -e "${RED}Download failed. Please check your internet connection.${NC}"
        exit 1
    fi
}

# Function to create bootable USB
create_bootable_usb() {
    local iso_file="$1"
    local usb_drive="$2"

    echo -e "${YELLOW}Preparing to write ${iso_file} to ${usb_drive}${NC}"
    echo -e "${RED}WARNING: All data on ${usb_drive} will be ERASED!${NC}"
    
    # Double-check with disk information
    echo -e "${YELLOW}Drive information for ${usb_drive}:${NC}"
    lsblk ${usb_drive} -o NAME,SIZE,MODEL,VENDOR,SERIAL,MOUNTPOINT
    
    # Ask user to verify they have the correct drive
    read -p "Is this the correct USB drive? (yes/no): " verify_drive
    if [[ "$verify_drive" != "yes" ]]; then
        echo -e "${RED}Operation cancelled. Please select the correct drive.${NC}"
        exit 1
    fi
    
    read -p "Are you sure you want to continue? All data will be erased. (yes/no): " confirm
    if [[ "$confirm" != "yes" ]]; then
        echo -e "${RED}Operation cancelled.${NC}"
        exit 1
    fi

    # Unmount any mounted partitions
    echo -e "${YELLOW}Unmounting any mounted partitions on ${usb_drive}...${NC}"
    umount "${usb_drive}"* 2>/dev/null

    # Check if this is actually a USB drive
    if ! udevadm info --query=property --name="${usb_drive}" | grep -q "ID_BUS=usb"; then
        echo -e "${RED}WARNING: ${usb_drive} does not appear to be a USB device!${NC}"
        read -p "Are you ABSOLUTELY SURE you want to continue? This might be your system drive! (yes/NO): " really_sure
        if [[ "$really_sure" != "yes" ]]; then
            echo -e "${RED}Operation cancelled.${NC}"
            exit 1
        fi
    fi

    # Write ISO to USB drive
    echo -e "${YELLOW}Writing ISO to USB drive (this may take a while)...${NC}"
    dd bs=4M if="${iso_file}" of="${usb_drive}" status=progress oflag=sync
    
    # Sync and verify
    echo -e "${YELLOW}Syncing file system...${NC}"
    sync
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}ISO written successfully to device!${NC}"
        
        # Verify that the boot sector has been written
        echo -e "${YELLOW}Verifying boot sector...${NC}"
        dd if=${usb_drive} bs=512 count=1 | hexdump -C | head -1
        
        echo -e "${GREEN}Bootable USB created successfully!${NC}"
    else
        echo -e "${RED}Failed to create bootable USB.${NC}"
        exit 1
    fi
}

# Function to clean up downloaded ISO file
cleanup_iso() {
    local iso_file="$1"
    
    echo -e "${YELLOW}Cleaning up...${NC}"
    
    # Ask user if they want to remove the ISO file
    read -p "Do you want to remove the downloaded ISO file? (yes/no): " remove_iso
    
    if [[ "$remove_iso" == "yes" ]]; then
        if [ -f "$iso_file" ]; then
            rm -f "$iso_file"
            echo -e "${GREEN}ISO file removed successfully.${NC}"
        else
            echo -e "${RED}ISO file not found.${NC}"
        fi
    else
        echo -e "${YELLOW}ISO file kept at: $(pwd)/${iso_file}${NC}"
    fi
}

# Function to add boot helper script
create_boot_helper() {
    local usb_drive="$1"
    
    echo -e "${YELLOW}Checking for EFI partition on the USB drive...${NC}"
    
    # Get the first partition that might be an EFI partition
    local efi_partition="${usb_drive}1"
    
    # Check if partition exists and has a filesystem
    if [ -b "$efi_partition" ]; then
        local mount_point="/mnt/arch_efi_temp"
        
        # Create temporary mount point
        mkdir -p "$mount_point"
        
        # Try to mount the EFI partition
        if mount "$efi_partition" "$mount_point" 2>/dev/null; then
            echo -e "${GREEN}Found mountable partition. Creating boot helper script...${NC}"
            
            # Create directory for script
            mkdir -p "$mount_point/EFI/BOOT/"
            
            # Create a simple script to help with boot issues
            cat > "$mount_point/EFI/BOOT/README.txt" << 'EOF'
ARCH LINUX BOOT TROUBLESHOOTING
==============================

If your system is not booting from this USB drive:

1. Enter your BIOS/UEFI settings (usually by pressing F2, DEL, F10, or ESC during startup)

2. Check the boot order and ensure USB boot is prioritized

3. If you have Secure Boot enabled, try disabling it

4. Some systems require Legacy/CSM boot mode for bootable USBs

5. Try a different USB port, preferably a USB 2.0 port if available

6. If all else fails, try creating the bootable USB using a different method such as:
   - Rufus (Windows)
   - balenaEtcher (Cross-platform)
   - dd command (Linux)
EOF
            
            # Unmount the partition
            umount "$mount_point"
            
            # Remove the temporary directory
            rmdir "$mount_point"
            
            echo -e "${GREEN}Boot helper information added to the USB drive.${NC}"
        else
            echo -e "${YELLOW}Could not mount EFI partition. Skipping boot helper creation.${NC}"
            rmdir "$mount_point"
        fi
    else
        echo -e "${YELLOW}No suitable partition found for boot helper. Skipping.${NC}"
    fi
}

# Function to copy repository content to USB drive
copy_repo_to_usb() {
    local usb_drive="$1"
    
    echo -e "${YELLOW}Preparing to copy Mango Linux Configuration repository to USB drive...${NC}"
    
    # Find a FAT32 partition on the USB drive that we can write to
    local data_partition=""
    local mount_point="/mnt/arch_data_temp"
    
    # Create mount point directory if it doesn't exist
    mkdir -p "$mount_point"
    
    # Look for partitions on the USB drive
    for partition in "${usb_drive}"*; do
        if [ -b "$partition" ] && [ "$partition" != "$usb_drive" ]; then
            # Try to mount the partition
            if mount "$partition" "$mount_point" 2>/dev/null; then
                # Check if we have write permissions
                if touch "$mount_point/test_write" 2>/dev/null; then
                    rm "$mount_point/test_write"
                    echo -e "${GREEN}Found writable partition: $partition${NC}"
                    data_partition="$partition"
                    break
                fi
                umount "$mount_point"
            fi
        fi
    done
    
    # If no suitable partition is found, we'll create a simple data partition
    if [ -z "$data_partition" ]; then
        echo -e "${YELLOW}No writable partition found. Creating a data partition...${NC}"
        
        # Get the last partition number
        local last_part_num=$(ls -1 "${usb_drive}"* | grep -oE '[0-9]+
    
    # Set the mount point
    local mount_point="/mnt/arch_data_temp"
    
    # Create a directory for the repository
    mkdir -p "$mount_point/mango-linux"
    
    # Get the script directory (where this script is located)
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    
    # Navigate to the root of the repository (assuming the standard structure)
    local repo_root="$(cd "$script_dir/../.." && pwd)"
    
    echo -e "${GREEN}Copying Mango Linux Configuration repository to USB drive...${NC}"
    echo -e "${YELLOW}Repository source: ${repo_root}${NC}"
    echo -e "${YELLOW}Destination: ${mount_point}/mango-linux${NC}"
    
    # Copy the repository content to the USB drive
    rsync -av --exclude ".git" "$repo_root/" "$mount_point/mango-linux/"
    
    # Create a README file on the USB drive
    cat > "$mount_point/README.txt" << EOF
MANGO LINUX CONFIGURATION
=========================

This USB drive contains:
1. Arch Linux installation media (boot from this USB to install Arch Linux)
2. Mango Linux Configuration repository (in the mango-linux directory)

To use the Mango Linux Configuration tools after booting from this USB:
1. Open a terminal
2. Navigate to the repository directory:
   cd /run/media/arch/mango-linux
   (Note: The actual mount path may vary depending on your system)
3. Run the installation script:
   ./install.sh

For more information, see the README.md file in the mango-linux directory.
EOF
    
    # Create a desktop shortcut file on the USB drive
    mkdir -p "$mount_point/mango-linux/launcher"
    cat > "$mount_point/mango-linux/launcher/mango-linux-install.desktop" << EOF
[Desktop Entry]
Type=Application
Terminal=true
Name=Mango Linux Install
Comment=Launch Mango Linux Installation
Exec=bash -c "cd \$(dirname \$(readlink -f %k))/.. && ./install.sh"
Icon=system-software-install
Categories=System;
EOF
    
    # Make the desktop file executable
    chmod +x "$mount_point/mango-linux/launcher/mango-linux-install.desktop"
    
    # Sync and unmount
    sync
    umount "$mount_point"
    rmdir "$mount_point"
    
    echo -e "${GREEN}Repository successfully copied to USB drive!${NC}"
    echo -e "${GREEN}You can now access the Mango Linux Configuration repository from the USB drive.${NC}"
}

# Main script execution
main() {
    # Check for sudo privileges
    check_sudo
    
    # Check for required dependencies
    check_dependencies

    # Clear screen
    clear

    # ASCII Art Header
    echo -e "${GREEN}"
    echo "   ___             _______  ___  ___  _______   _________  ___  ___       _______  _______   "
    echo "  |\\  \\           /\\   _  \\/\\  \\/\\  \\/\\   _  \\ /\\   _____\\/\\  \\/\\  \\     /\\   _  \\/\\   __  \\ "
    echo "  \\ \\  \\         /  \\  \\L\\ \\ \\  \\_\\  \\ \\  \\L\\ \\\\ \\  \\__/\\_\\ \\  \\\\\\  \\    \\ \\  \\L\\ \\ \\  \\/\\  \\"
    echo "   \\ \\  \\        \\ \\   __  \\ \\  __  \\ \\   __/ \\ \\  \\  \\|_|\\ \\   __  \\    \\ \\   __\\ \\  \\\\\\  \\"
    echo "    \\ \\  \\____    \\ \\  \\/\\  \\ \\  \\/\\  \\ \\  \\/   \\ \\  \\     \\ \\  \\/\\  \\    \\ \\  \\_|\\ \\  \\_\\  \\"
    echo "     \\ \\_______\\   \\ \\__\\/\\__\\ \\__\\/\\__\\ \\__\\    \\ \\__\\     \\ \\__\\/\\__\\    \\ \\_______\\ \\_______\\"
    echo "      \\|_______|    \\|__/\\|__/\\|__/\\|__/\\|__|     \\|__|      \\|__/\\|__|     \\|_______/\\|_______|"
    echo -e "${NC}"
    echo -e "${YELLOW}Arch Linux USB Creator - Mango Linux Configuration Edition${NC}"
    echo -e "${GREEN}Using Arch Linux version: ${ARCH_VERSION}${NC}"
    echo ""

    # List available USB drives
    list_usb_drives

    # Prompt for USB drive
    read -p "Enter the USB drive path (e.g., /dev/sdb): " usb_drive

    # Store the ISO filename
    local iso_filename="archlinux-${ARCH_VERSION}-x86_64.iso"
    
    # Download ISO from MIT mirror
    download_iso

    # Create bootable USB
    create_bootable_usb "$iso_filename" "${usb_drive}"
    
    # Create boot helper information on the USB
    create_boot_helper "${usb_drive}"
    
    # Copy repository content to the USB drive
    copy_repo_to_usb "${usb_drive}"
    
    echo -e "\n${YELLOW}=== BOOT INSTRUCTIONS ===${NC}"
    echo -e "${GREEN}To boot from this USB drive:${NC}"
    echo -e "1. Restart your computer"
    echo -e "2. During startup, press the boot menu key for your system:"
    echo -e "   - Dell: F12"
    echo -e "   - HP: F9"
    echo -e "   - Lenovo: F12 or Fn+F12"
    echo -e "   - ASUS: F8"
    echo -e "   - Acer: F12"
    echo -e "   - MSI: F11"
    echo -e "   - Apple Mac: Hold Option/Alt key"
    echo -e "3. Select the USB drive from the boot menu"
    echo -e "\n${YELLOW}To access Mango Linux Configuration:${NC}"
    echo -e "• After booting into Arch Linux, mount the USB drive"
    echo -e "• Navigate to the mango-linux folder on the USB"
    echo -e "• Run ./install.sh to access all Mango Linux tools\n"
    
    # Clean up the ISO file after successful USB creation
    cleanup_iso "$iso_filename"
}

# Run the main function
main
 | sort -n | tail -1)
        
        # Create a new simple partition at the end of the drive
        parted -s "$usb_drive" mkpart primary ext4 100% 100%
        
        # Get the new partition name
        if [[ "$usb_drive" == *"nvme"* ]]; then
            data_partition="${usb_drive}p$((last_part_num + 1))"
        else
            data_partition="${usb_drive}$((last_part_num + 1))"
        fi
        
        # Format the partition as ext4
        echo -e "${YELLOW}Formatting data partition as ext4...${NC}"
        mkfs.ext4 -F "$data_partition"
        
        # Mount the new partition
        mount "$data_partition" "$mount_point"
    fi
    
    # Set the mount point
    local mount_point="/mnt/arch_data_temp"
    
    # Create a directory for the repository
    mkdir -p "$mount_point/mango-linux"
    
    # Get the script directory (where this script is located)
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    
    # Navigate to the root of the repository (assuming the standard structure)
    local repo_root="$(cd "$script_dir/../.." && pwd)"
    
    echo -e "${GREEN}Copying Mango Linux Configuration repository to USB drive...${NC}"
    echo -e "${YELLOW}Repository source: ${repo_root}${NC}"
    echo -e "${YELLOW}Destination: ${mount_point}/mango-linux${NC}"
    
    # Copy the repository content to the USB drive
    rsync -av --exclude ".git" "$repo_root/" "$mount_point/mango-linux/"
    
    # Create a README file on the USB drive
    cat > "$mount_point/README.txt" << EOF
MANGO LINUX CONFIGURATION
=========================

This USB drive contains:
1. Arch Linux installation media (boot from this USB to install Arch Linux)
2. Mango Linux Configuration repository (in the mango-linux directory)

To use the Mango Linux Configuration tools after booting from this USB:
1. Open a terminal
2. Navigate to the repository directory:
   cd /run/media/arch/mango-linux
   (Note: The actual mount path may vary depending on your system)
3. Run the installation script:
   ./install.sh

For more information, see the README.md file in the mango-linux directory.
EOF
    
    # Create a desktop shortcut file on the USB drive
    mkdir -p "$mount_point/mango-linux/launcher"
    cat > "$mount_point/mango-linux/launcher/mango-linux-install.desktop" << EOF
[Desktop Entry]
Type=Application
Terminal=true
Name=Mango Linux Install
Comment=Launch Mango Linux Installation
Exec=bash -c "cd \$(dirname \$(readlink -f %k))/.. && ./install.sh"
Icon=system-software-install
Categories=System;
EOF
    
    # Make the desktop file executable
    chmod +x "$mount_point/mango-linux/launcher/mango-linux-install.desktop"
    
    # Sync and unmount
    sync
    umount "$mount_point"
    rmdir "$mount_point"
    
    echo -e "${GREEN}Repository successfully copied to USB drive!${NC}"
    echo -e "${GREEN}You can now access the Mango Linux Configuration repository from the USB drive.${NC}"
}

# Main script execution
main() {
    # Check for sudo privileges
    check_sudo
    
    # Check for required dependencies
    check_dependencies

    # Clear screen
    clear

    # ASCII Art Header
    echo -e "${GREEN}"
    echo "   ___             _______  ___  ___  _______   _________  ___  ___       _______  _______   "
    echo "  |\\  \\           /\\   _  \\/\\  \\/\\  \\/\\   _  \\ /\\   _____\\/\\  \\/\\  \\     /\\   _  \\/\\   __  \\ "
    echo "  \\ \\  \\         /  \\  \\L\\ \\ \\  \\_\\  \\ \\  \\L\\ \\\\ \\  \\__/\\_\\ \\  \\\\\\  \\    \\ \\  \\L\\ \\ \\  \\/\\  \\"
    echo "   \\ \\  \\        \\ \\   __  \\ \\  __  \\ \\   __/ \\ \\  \\  \\|_|\\ \\   __  \\    \\ \\   __\\ \\  \\\\\\  \\"
    echo "    \\ \\  \\____    \\ \\  \\/\\  \\ \\  \\/\\  \\ \\  \\/   \\ \\  \\     \\ \\  \\/\\  \\    \\ \\  \\_|\\ \\  \\_\\  \\"
    echo "     \\ \\_______\\   \\ \\__\\/\\__\\ \\__\\/\\__\\ \\__\\    \\ \\__\\     \\ \\__\\/\\__\\    \\ \\_______\\ \\_______\\"
    echo "      \\|_______|    \\|__/\\|__/\\|__/\\|__/\\|__|     \\|__|      \\|__/\\|__|     \\|_______/\\|_______|"
    echo -e "${NC}"
    echo -e "${YELLOW}Arch Linux USB Creator - Mango Linux Configuration Edition${NC}"
    echo -e "${GREEN}Using Arch Linux version: ${ARCH_VERSION}${NC}"
    echo ""

    # List available USB drives
    list_usb_drives

    # Prompt for USB drive
    read -p "Enter the USB drive path (e.g., /dev/sdb): " usb_drive

    # Store the ISO filename
    local iso_filename="archlinux-${ARCH_VERSION}-x86_64.iso"
    
    # Download ISO from MIT mirror
    download_iso

    # Create bootable USB
    create_bootable_usb "$iso_filename" "${usb_drive}"
    
    # Create boot helper information on the USB
    create_boot_helper "${usb_drive}"
    
    # Copy repository content to the USB drive
    copy_repo_to_usb "${usb_drive}"
    
    echo -e "\n${YELLOW}=== BOOT INSTRUCTIONS ===${NC}"
    echo -e "${GREEN}To boot from this USB drive:${NC}"
    echo -e "1. Restart your computer"
    echo -e "2. During startup, press the boot menu key for your system:"
    echo -e "   - Dell: F12"
    echo -e "   - HP: F9"
    echo -e "   - Lenovo: F12 or Fn+F12"
    echo -e "   - ASUS: F8"
    echo -e "   - Acer: F12"
    echo -e "   - MSI: F11"
    echo -e "   - Apple Mac: Hold Option/Alt key"
    echo -e "3. Select the USB drive from the boot menu"
    echo -e "\n${YELLOW}To access Mango Linux Configuration:${NC}"
    echo -e "• After booting into Arch Linux, mount the USB drive"
    echo -e "• Navigate to the mango-linux folder on the USB"
    echo -e "• Run ./install.sh to access all Mango Linux tools\n"
    
    # Clean up the ISO file after successful USB creation
    cleanup_iso "$iso_filename"
}

# Run the main function
main





### FILE: ./scripts/bootable-usb/modules/check_dependencies.sh

#!/bin/bash
# Module: check_dependencies.sh
# Handles checking for dependencies and sudo privileges

# Function to check if script is run with sudo
check_sudo() {
    if [ "$EUID" -ne 0 ]; then
        echo -e "${RED}Please run this script with sudo or as root${NC}"
        exit 1
    fi
}

# Function to check if required tools are installed
check_dependencies() {
    local deps=("wget" "dd" "grep" "rsync")
    local missing=()

    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing+=("$dep")
        fi
    done

    if [ ${#missing[@]} -ne 0 ]; then
        echo -e "${RED}The following dependencies are missing:${NC}"
        printf "  %s\n" "${missing[@]}"
        echo -e "${YELLOW}Please install them using your package manager and try again.${NC}"
        exit 1
    fi
}





### FILE: ./scripts/bootable-usb/modules/disk_operations.sh

#!/bin/bash
# Module: disk_operations.sh
# Handles USB drive operations

# Function to list available USB drives
list_usb_drives() {
    echo -e "${YELLOW}Available USB Drives:${NC}"
    lsblk -do NAME,SIZE,TYPE,MOUNTPOINT | grep -E 'sd[b-z]|usb'
}

# Function to create bootable USB
create_bootable_usb() {
    local iso_file="$1"
    local usb_drive="$2"

    echo -e "${YELLOW}Preparing to write ${iso_file} to ${usb_drive}${NC}"
    echo -e "${RED}WARNING: All data on ${usb_drive} will be ERASED!${NC}"
    
    # Double-check with disk information
    echo -e "${YELLOW}Drive information for ${usb_drive}:${NC}"
    lsblk ${usb_drive} -o NAME,SIZE,MODEL,VENDOR,SERIAL,MOUNTPOINT
    
    # Ask user to verify they have the correct drive
    read -p "Is this the correct USB drive? (yes/no): " verify_drive
    if [[ "$verify_drive" != "yes" ]]; then
        echo -e "${RED}Operation cancelled. Please select the correct drive.${NC}"
        exit 1
    fi
    
    read -p "Are you sure you want to continue? All data will be erased. (yes/no): " confirm
    if [[ "$confirm" != "yes" ]]; then
        echo -e "${RED}Operation cancelled.${NC}"
        exit 1
    fi

    # Unmount any mounted partitions
    echo -e "${YELLOW}Unmounting any mounted partitions on ${usb_drive}...${NC}"
    umount "${usb_drive}"* 2>/dev/null

    # Check if this is actually a USB drive
    if ! udevadm info --query=property --name="${usb_drive}" | grep -q "ID_BUS=usb"; then
        echo -e "${RED}WARNING: ${usb_drive} does not appear to be a USB device!${NC}"
        read -p "Are you ABSOLUTELY SURE you want to continue? This might be your system drive! (yes/NO): " really_sure
        if [[ "$really_sure" != "yes" ]]; then
            echo -e "${RED}Operation cancelled.${NC}"
            exit 1
        fi
    fi

    # Write ISO to USB drive
    echo -e "${YELLOW}Writing ISO to USB drive (this may take a while)...${NC}"
    dd bs=4M if="${iso_file}" of="${usb_drive}" status=progress oflag=sync
    
    # Sync and verify
    echo -e "${YELLOW}Syncing file system...${NC}"
    sync
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}ISO written successfully to device!${NC}"
        
        # Verify that the boot sector has been written
        echo -e "${YELLOW}Verifying boot sector...${NC}"
        dd if=${usb_drive} bs=512 count=1 | hexdump -C | head -1
        
        echo -e "${GREEN}Bootable USB created successfully!${NC}"
    else
        echo -e "${RED}Failed to create bootable USB.${NC}"
        exit 1
    fi
}

# Function to create boot helper script
create_boot_helper() {
    local usb_drive="$1"
    
    echo -e "${YELLOW}Checking for EFI partition on the USB drive...${NC}"
    
    # Get the first partition that might be an EFI partition
    local efi_partition="${usb_drive}1"
    
    # Check if partition exists and has a filesystem
    if [ -b "$efi_partition" ]; then
        local mount_point="/mnt/arch_efi_temp"
        
        # Create temporary mount point
        mkdir -p "$mount_point"
        
        # Try to mount the EFI partition
        if mount "$efi_partition" "$mount_point" 2>/dev/null; then
            echo -e "${GREEN}Found mountable partition. Creating boot helper script...${NC}"
            
            # Create directory for script
            mkdir -p "$mount_point/EFI/BOOT/"
            
            # Create a simple script to help with boot issues
            cat > "$mount_point/EFI/BOOT/README.txt" << 'EOF'
ARCH LINUX BOOT TROUBLESHOOTING
==============================

If your system is not booting from this USB drive:

1. Enter your BIOS/UEFI settings (usually by pressing F2, DEL, F10, or ESC during startup)

2. Check the boot order and ensure USB boot is prioritized

3. If you have Secure Boot enabled, try disabling it

4. Some systems require Legacy/CSM boot mode for bootable USBs

5. Try a different USB port, preferably a USB 2.0 port if available

6. If all else fails, try creating the bootable USB using a different method such as:
   - Rufus (Windows)
   - balenaEtcher (Cross-platform)
   - dd command (Linux)
EOF
            
            # Unmount the partition
            umount "$mount_point"
            
            # Remove the temporary directory
            rmdir "$mount_point"
            
            echo -e "${GREEN}Boot helper information added to the USB drive.${NC}"
        else
            echo -e "${YELLOW}Could not mount EFI partition. Skipping boot helper creation.${NC}"
            rmdir "$mount_point"
        fi
    else
        echo -e "${YELLOW}No suitable partition found for boot helper. Skipping.${NC}"
    fi
}





### FILE: ./scripts/bootable-usb/modules/iso_handling.sh

#!/bin/bash
# Module: iso_handling.sh
# Handles ISO download and cleanup

# Function to download Arch Linux ISO
download_iso() {
    local iso_filename="$1"
    local iso_url="$2"

    # Check if ISO already exists
    if [ -f "${iso_filename}" ]; then
        echo -e "${YELLOW}ISO file ${iso_filename} already exists.${NC}"
        read -p "Use existing file? (yes/no): " use_existing
        if [[ "$use_existing" == "yes" ]]; then
            echo -e "${GREEN}Using existing ISO file.${NC}"
            return 0
        fi
    fi

    echo -e "${GREEN}Downloading Arch Linux ISO from MIT mirror...${NC}"
    echo -e "${YELLOW}URL: ${iso_url}${NC}"
    
    # Download with wget, showing progress
    wget --progress=bar:force -O "${iso_filename}" "${iso_url}"

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Download complete: ${iso_filename}${NC}"
        
        # Verify download by checking file size
        local file_size=$(stat -c %s "${iso_filename}")
        if [ "$file_size" -lt 700000000 ]; then  # ISO should be at least ~700MB
            echo -e "${RED}Warning: Downloaded file seems too small (${file_size} bytes).${NC}"
            echo -e "${YELLOW}The download might be incomplete or corrupted.${NC}"
            read -p "Do you want to continue anyway? (yes/no): " continue_anyway
            if [[ "$continue_anyway" != "yes" ]]; then
                echo -e "${RED}Operation cancelled.${NC}"
                exit 1
            fi
        fi
    else
        echo -e "${RED}Download failed. Please check your internet connection.${NC}"
        exit 1
    fi
}

# Function to clean up downloaded ISO file
cleanup_iso() {
    local iso_file="$1"
    
    echo -e "${YELLOW}Cleaning up...${NC}"
    
    # Ask user if they want to remove the ISO file
    read -p "Do you want to remove the downloaded ISO file? (yes/no): " remove_iso
    
    if [[ "$remove_iso" == "yes" ]]; then
        if [ -f "$iso_file" ]; then
            rm -f "$iso_file"
            echo -e "${GREEN}ISO file removed successfully.${NC}"
        else
            echo -e "${RED}ISO file not found.${NC}"
        fi
    else
        echo -e "${YELLOW}ISO file kept at: $(pwd)/${iso_file}${NC}"
    fi
}





### FILE: ./scripts/bootable-usb/modules/live-env-setup.sh

#!/bin/bash
# live-env-setup.sh
# Script to automatically configure Mango Linux Configuration in the live environment

# Colors for formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Display header
echo -e "${GREEN}"
echo "   __  ___                            __    _                  "
echo "  /  |/  /___ _____  ____ _____     / /   (_)___  __  ___  __ "
echo " / /|_/ / __ \`/ __ \/ __ \`/ __ \   / /   / / __ \/ / / / |/_/ "
echo "/ /  / / /_/ / / / / /_/ / /_/ /  / /___/ / / / / /_/ />  <   "
echo "/_/  /_/\__,_/_/ /_/\__, /\____/  /_____/_/_/ /_/\__,_/_/|_|   "
echo "                   /____/                                      "
echo -e "${NC}"
echo -e "${YELLOW}Mango Linux Configuration - Live Environment Setup${NC}"
echo -e "${BLUE}Preparing for use in the Arch Linux live environment${NC}"
echo "-----------------------------------------------------------------------"

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    echo -e "${RED}Please run this script with sudo or as root${NC}"
    exit 1
fi

# Function to find USB drive with Mango Linux
find_usb_drive() {
    local found_drive=""
    
    echo -e "${YELLOW}Searching for Mango Linux Configuration USB drive...${NC}"
    
    # Create temporary mount point
    local mount_point="/tmp/mango_usb_temp"
    mkdir -p "$mount_point"
    
    # Check all removable drives
    for drive in /dev/sd*; do
        if [[ $drive =~ /dev/sd[a-z]$ ]]; then
            continue  # Skip disk, only check partitions
        fi
        
        # Try to mount the partition
        if mount "$drive" "$mount_point" 2>/dev/null; then
            # Check if this contains our repository
            if [ -d "$mount_point/mango-linux" ]; then
                found_drive="$drive"
                umount "$mount_point"
                break
            fi
            umount "$mount_point"
        fi
    done
    
    # Remove temporary mount point
    rmdir "$mount_point"
    
    if [ -n "$found_drive" ]; then
        echo -e "${GREEN}Found Mango Linux Configuration on $found_drive${NC}"
        echo "$found_drive"
        return 0
    else
        echo -e "${RED}Could not find Mango Linux Configuration USB drive${NC}"
        return 1
    fi
}

# Function to copy repository to home directory
copy_to_home() {
    local usb_drive="$1"
    local mount_point="/mnt/mango_usb"
    
    # Create mount point
    mkdir -p "$mount_point"
    
    # Mount USB drive
    if ! mount "$usb_drive" "$mount_point"; then
        echo -e "${RED}Failed to mount USB drive${NC}"
        rmdir "$mount_point"
        return 1
    fi
    
    # Define home directory
    local home_dir="/home/arch"
    local dest_dir="${home_dir}/mango-linux"
    
    echo -e "${YELLOW}Copying Mango Linux Configuration to home directory...${NC}"
    
    # Create destination directory
    mkdir -p "$dest_dir"
    
    # Copy repository files
    rsync -av --exclude ".git" "$mount_point/mango-linux/" "$dest_dir/"
    
    # Set proper permissions
    chown -R arch:arch "$dest_dir"
    chmod +x "$dest_dir/install.sh"
    
    # Create desktop shortcut
    mkdir -p "${home_dir}/Desktop"
    cat > "${home_dir}/Desktop/mango-linux-install.desktop" << EOF
[Desktop Entry]
Type=Application
Terminal=true
Name=Mango Linux Install
Comment=Launch Mango Linux Installation
Exec=bash -c "cd ${dest_dir} && ./install.sh"
Icon=system-software-install
Categories=System;
EOF
    
    # Make the desktop file executable
    chmod +x "${home_dir}/Desktop/mango-linux-install.desktop"
    chown arch:arch "${home_dir}/Desktop/mango-linux-install.desktop"
    
    # Unmount the USB drive
    umount "$mount_point"
    rmdir "$mount_point"
    
    echo -e "${GREEN}Setup complete!${NC}"
    echo -e "You can now access Mango Linux Configuration at ${dest_dir}"
    echo -e "Or run it directly from the desktop shortcut"
    
    return 0
}

# Main function
main() {
    echo -e "${YELLOW}Setting up Mango Linux Configuration in live environment...${NC}"
    
    # Find the USB drive
    local usb_drive=$(find_usb_drive)
    
    if [ $? -ne 0 ]; then
        echo -e "${YELLOW}Attempting manual search...${NC}"
        
        # List available drives
        echo -e "Available drives:"
        lsblk -o NAME,SIZE,FSTYPE,LABEL,MOUNTPOINT
        
        # Ask user to specify the drive
        read -p "Enter the partition containing Mango Linux (e.g., /dev/sdb1): " usb_drive
        
        if [ ! -b "$usb_drive" ]; then
            echo -e "${RED}Invalid drive specified.${NC}"
            exit 1
        fi
    fi
    
    # Copy repository to home directory
    copy_to_home "$usb_drive"
    
    if [ $? -eq 0 ]; then
        echo -e "\n${GREEN}Mango Linux Configuration is ready to use!${NC}"
        echo -e "To start, run: cd ~/mango-linux && ./install.sh"
        
        # Create autostart entry for desktop
        if [ -d "/home/arch/.config" ]; then
            mkdir -p "/home/arch/.config/autostart"
            cat > "/home/arch/.config/autostart/mango-welcome.desktop" << EOF
[Desktop Entry]
Type=Application
Terminal=true
Name=Mango Linux Welcome
Comment=Welcome to Mango Linux Configuration
Exec=bash -c "echo -e '\033[0;32mWelcome to Mango Linux Configuration!\033[0m\nThe configuration tools are available in ~/mango-linux\nRun ./install.sh to get started.'"
Icon=system-software-install
Categories=System;
EOF
            chmod +x "/home/arch/.config/autostart/mango-welcome.desktop"
            chown -R arch:arch "/home/arch/.config/autostart"
        fi
    else
        echo -e "${RED}Failed to set up Mango Linux Configuration.${NC}"
        exit 1
    fi
}

# Run the main function
main




### FILE: ./scripts/bootable-usb/modules/repo_integration.sh

#!/bin/bash
# Module: repo_integration.sh
# Handles the integration of the repository content into the USB drive

# Function to copy repository content to USB drive
copy_repo_to_usb() {
    local usb_drive="$1"
    local repo_root="$2"
    
    echo -e "${YELLOW}Preparing to copy Mango Linux Configuration repository to USB drive...${NC}"
    
    # Find a FAT32 partition on the USB drive that we can write to
    local data_partition=""
    local mount_point="/mnt/arch_data_temp"
    
    # Create mount point directory if it doesn't exist
    mkdir -p "$mount_point"
    
    # Look for partitions on the USB drive
    for partition in "${usb_drive}"*; do
        if [ -b "$partition" ] && [ "$partition" != "$usb_drive" ]; then
            # Try to mount the partition
            if mount "$partition" "$mount_point" 2>/dev/null; then
                # Check if we have write permissions
                if touch "$mount_point/test_write" 2>/dev/null; then
                    rm "$mount_point/test_write"
                    echo -e "${GREEN}Found writable partition: $partition${NC}"
                    data_partition="$partition"
                    break
                fi
                umount "$mount_point"
            fi
        fi
    done
    
    # If no suitable partition is found, we'll create a simple data partition
    if [ -z "$data_partition" ]; then
        echo -e "${YELLOW}No writable partition found. Creating a data partition...${NC}"
        
        # Get the last partition number
        local last_part_num=$(ls -1 "${usb_drive}"* | grep -oE '[0-9]+$' | sort -n | tail -1)
        
        # Create a new simple partition at the end of the drive
        parted -s "$usb_drive" mkpart primary ext4 100% 100%
        
        # Get the new partition name
        if [[ "$usb_drive" == *"nvme"* ]]; then
            data_partition="${usb_drive}p$((last_part_num + 1))"
        else
            data_partition="${usb_drive}$((last_part_num + 1))"
        fi
        
        # Format the partition as ext4
        echo -e "${YELLOW}Formatting data partition as ext4...${NC}"
        mkfs.ext4 -F "$data_partition"
        
        # Mount the new partition
        mount "$data_partition" "$mount_point"
    fi
    
    # Create a directory for the repository
    mkdir -p "$mount_point/mango-linux"
    
    echo -e "${GREEN}Copying Mango Linux Configuration repository to USB drive...${NC}"
    echo -e "${YELLOW}Repository source: ${repo_root}${NC}"
    echo -e "${YELLOW}Destination: ${mount_point}/mango-linux${NC}"
    
    # Copy the repository content to the USB drive
    rsync -av --exclude ".git" "$repo_root/" "$mount_point/mango-linux/"
    
    # Create a README file on the USB drive
    cat > "$mount_point/README.txt" << EOF
MANGO LINUX CONFIGURATION
=========================

This USB drive contains:
1. Arch Linux installation media (boot from this USB to install Arch Linux)
2. Mango Linux Configuration repository (in the mango-linux directory)

To use the Mango Linux Configuration tools after booting from this USB:
1. Open a terminal
2. Navigate to the repository directory:
   cd /run/media/arch/mango-linux
   (Note: The actual mount path may vary depending on your system)
3. Run the installation script:
   ./install.sh

For more information, see the README.md file in the mango-linux directory.
EOF
    
    # Create a desktop shortcut file on the USB drive
    mkdir -p "$mount_point/mango-linux/launcher"
    cat > "$mount_point/mango-linux/launcher/mango-linux-install.desktop" << EOF
[Desktop Entry]
Type=Application
Terminal=true
Name=Mango Linux Install
Comment=Launch Mango Linux Installation
Exec=bash -c "cd \$(dirname \$(readlink -f %k))/.. && ./install.sh"
Icon=system-software-install
Categories=System;
EOF
    
    # Make the desktop file executable
    chmod +x "$mount_point/mango-linux/launcher/mango-linux-install.desktop"
    
    # Create live environment integration script
    create_live_env_integration "$mount_point"
    
    # Sync and unmount
    sync
    umount "$mount_point"
    rmdir "$mount_point"
    
    echo -e "${GREEN}Repository successfully copied to USB drive!${NC}"
    echo -e "${GREEN}You can now access the Mango Linux Configuration repository from the USB drive.${NC}"
}

# Function to create live environment integration script
create_live_env_integration() {
    local mount_point="$1"
    
    echo -e "${YELLOW}Creating live environment integration script...${NC}"
    
    # Create script to copy repository to home directory in live environment
    cat > "$mount_point/mango-linux/copy-to-home.sh" << 'EOF'
#!/bin/bash

# Script to copy Mango Linux Configuration to home directory in live environment
# This script is automatically executed when using the Live Environment

# Colors for formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}Mango Linux Configuration - Live Environment Setup${NC}"

# Find the USB drive containing this script
SCRIPT_PATH=$(readlink -f "$0")
SCRIPT_DIR=$(dirname "$SCRIPT_PATH")
REPO_DIR=$(dirname "$SCRIPT_DIR")

# Destination in home directory
HOME_DIR="/home/arch"
DEST_DIR="${HOME_DIR}/mango-linux"

# Create destination directory if it doesn't exist
mkdir -p "$DEST_DIR"

# Copy repository to home directory
echo -e "${YELLOW}Copying Mango Linux Configuration to home directory...${NC}"
rsync -av --exclude ".git" "$REPO_DIR/" "$DEST_DIR/"

# Set proper permissions
chown -R arch:arch "$DEST_DIR"
chmod +x "$DEST_DIR/install.sh"

# Create desktop shortcut
mkdir -p "${HOME_DIR}/Desktop"
cat > "${HOME_DIR}/Desktop/mango-linux-install.desktop" << EOD
[Desktop Entry]
Type=Application
Terminal=true
Name=Mango Linux Install
Comment=Launch Mango Linux Installation
Exec=bash -c "cd ${DEST_DIR} && ./install.sh"
Icon=system-software-install
Categories=System;
EOD

# Make the desktop file executable
chmod +x "${HOME_DIR}/Desktop/mango-linux-install.desktop"
chown arch:arch "${HOME_DIR}/Desktop/mango-linux-install.desktop"

echo -e "${GREEN}Setup complete!${NC}"
echo -e "You can now access Mango Linux Configuration at ${DEST_DIR}"
echo -e "Or run it directly from the desktop shortcut"

EOF
    
    # Make the script executable
    chmod +x "$mount_point/mango-linux/copy-to-home.sh"
    
    # Create systemd service to run script at boot in live environment
    mkdir -p "$mount_point/mango-linux/live-setup"
    
    cat > "$mount_point/mango-linux/live-setup/mango-linux-live.service" << EOF
[Unit]
Description=Mango Linux Configuration Live Environment Setup
After=display-manager.service

[Service]
Type=oneshot
ExecStart=/bin/bash /run/media/arch/mango-linux/copy-to-home.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
    
    # Create readme for live environment integration
    cat > "$mount_point/mango-linux/live-setup/README.md" << EOF
# Live Environment Integration

This directory contains files to integrate Mango Linux Configuration with the Arch Linux live environment.

## Manual Setup

If the automatic integration doesn't work, you can manually set up the environment:

1. Boot from the Arch Linux USB
2. Open a terminal
3. Find and mount the USB drive:
   \`\`\`
   lsblk
   # Find the USB drive (likely /dev/sdb)
   mkdir -p /mnt/usb
   mount /dev/sdX# /mnt/usb  # Replace X# with your USB partition
   \`\`\`
4. Run the copy script:
   \`\`\`
   sudo bash /mnt/usb/mango-linux/copy-to-home.sh
   \`\`\`
5. Navigate to the copied repository:
   \`\`\`
   cd ~/mango-linux
   \`\`\`
6. Run the installation script:
   \`\`\`
   ./install.sh
   \`\`\`

## How It Works

The \`copy-to-home.sh\` script:
1. Copies the Mango Linux Configuration repository to the home directory
2. Creates a desktop shortcut for easy access
3. Sets appropriate permissions

EOF
    
    echo -e "${GREEN}Live environment integration script created!${NC}"
}





### FILE: ./scripts/bootable-usb/README.md

# Arch Linux USB Creator

## Overview

A modular bash script system to create a customized bootable Arch Linux USB drive with version and architecture selection, including integrated Mango Linux Configuration.

## Features

- Modular architecture for easier maintenance
- Select specific Arch Linux version
- Automatically downloads selected ISO
- Lists available USB drives
- Creates a bootable USB drive
- Integrates Mango Linux Configuration for use in live environment
- Provides desktop shortcuts for easy access

## Directory Structure

```
scripts/bootable-usb/
├── arch-usb-creator.sh        # Main script
├── live-env-setup.sh          # Script for live environment integration
├── modules/                   # Modular components
│   ├── check_dependencies.sh  # Dependency checking
│   ├── disk_operations.sh     # USB drive operations
│   ├── iso_handling.sh        # ISO download and verification
│   └── repo_integration.sh    # Repository integration
└── README.md                  # This documentation
```

## Prerequisites

### Software Dependencies
- wget
- dd
- grep
- rsync

### Recommended System
- Any Linux distribution
- Root/sudo access
- Internet connection

## Usage

1. Make the script executable:
   ```bash
   chmod +x arch-usb-creator.sh
   ```

2. Run with sudo:
   ```bash
   sudo ./arch-usb-creator.sh
   ```

3. Interactive Prompts
   - Select target USB drive
   - Confirm USB drive selection
   - Choose whether to keep the ISO file

## Live Environment Integration

The created USB drive includes functionality to copy the Mango Linux Configuration repository to the home directory when booting from the live environment.

### Automatic Integration

When booting from the Arch Linux live environment, the system will:
1. Look for the Mango Linux Configuration USB drive
2. Copy the repository to the home directory
3. Create a desktop shortcut for easy access

### Manual Integration

If automatic integration doesn't work:
1. Boot from the Arch Linux USB
2. Open a terminal
3. Run the following command:
   ```bash
   sudo /run/media/arch/*/mango-linux/live-env-setup.sh
   ```

## Warning

⚠️ **IMPORTANT**: 
- This script will COMPLETELY ERASE the selected USB drive
- Ensure you have backed up any important data on the USB drive
- Carefully select the correct USB drive when prompted

## Customization

- To change the Arch Linux version, edit the `ARCH_VERSION` variable in `arch-usb-creator.sh`
- To modify the repository integration process, edit the `copy_repo_to_usb` function in `modules/repo_integration.sh`

## Troubleshooting

- Ensure all dependencies are installed
- Check internet connection
- Verify USB drive is properly connected
- Run script with sufficient permissions (sudo)





### FILE: ./scripts/determine-arch-ver/linux-os-discovery-updated.sh

#!/bin/bash

# Variable to store architecture
ARCH=""
# Variable to store CPU type
CPU_TYPE=""
# Variable to store if system is UEFI
IS_UEFI=false
# Variable to hold recommended Arch Linux version
ARCH_RECOMMENDATION=""
# Variable to store RAM in KB
TOTAL_MEM=0
# Variable to store GPU information
GPU_INFO=""
# Variable to check if system is virtual
IS_VIRTUAL=false

echo "Analyzing system to determine appropriate Arch Linux version..."

# Get architecture
ARCH=$(uname -m)

# Get CPU information
if [ "$(uname)" == "Darwin" ]; then
    # macOS
    CPU_INFO=$(sysctl -n machdep.cpu.brand_string)
    
    # Determine CPU type for Mac
    if echo "$CPU_INFO" | grep -q "Intel"; then
        CPU_TYPE="intel"
    elif echo "$CPU_INFO" | grep -q "Apple"; then
        CPU_TYPE="arm"
    fi
    
    # Get memory information
    TOTAL_MEM=$(( $(sysctl -n hw.memsize) / 1024 ))
else
    # Linux
    if [ -f /proc/cpuinfo ]; then
        CPU_INFO=$(grep -m 1 "model name" /proc/cpuinfo | cut -d ":" -f2 | sed 's/^[ \t]*//')
        
        # Determine CPU type
        if echo "$CPU_INFO" | grep -q "Intel"; then
            CPU_TYPE="intel"
        elif echo "$CPU_INFO" | grep -q "AMD"; then
            CPU_TYPE="amd"
        elif echo "$CPU_INFO" | grep -q "ARM"; then
            CPU_TYPE="arm"
        fi
        
        # Get memory information
        if [ -f /proc/meminfo ]; then
            TOTAL_MEM=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        fi
    fi
fi

# Check for UEFI boot
if command -v efibootmgr >/dev/null 2>&1; then
    IS_UEFI=true
elif [ -d /sys/firmware/efi ]; then
    IS_UEFI=true
else
    IS_UEFI=false
fi

# Get GPU information
if [ "$(uname)" == "Darwin" ]; then
    # macOS
    GPU_INFO=$(system_profiler SPDisplaysDataType | grep -E "Chipset|Model|VRAM")
else
    # Linux
    if command -v lspci >/dev/null 2>&1; then
        GPU_INFO=$(lspci | grep -E "VGA|3D|Display")
    elif command -v glxinfo >/dev/null 2>&1; then
        GPU_INFO=$(glxinfo | grep -E "OpenGL vendor|OpenGL renderer")
    fi
fi

# Check for virtualization
if command -v systemd-detect-virt >/dev/null 2>&1; then
    VIRT=$(systemd-detect-virt)
    if [ "$VIRT" != "none" ]; then
        IS_VIRTUAL=true
    fi
elif grep -q "^flags.*svm" /proc/cpuinfo || grep -q "^flags.*vmx" /proc/cpuinfo; then
    # Has virtualization capability, but may not be a VM
    if grep -q "hypervisor" /proc/cpuinfo; then
        IS_VIRTUAL=true
    fi
fi

# Convert memory to GB for display
MEM_GB=$(echo "scale=2; $TOTAL_MEM / 1024 / 1024" | bc)

# Determine recommended Arch Linux version
# Determine based on architecture
if [ "$ARCH" == "x86_64" ]; then
    if (( $(echo "$MEM_GB < 1" | bc -l) )); then
        ARCH_RECOMMENDATION="Arch Linux 32 (due to low RAM: ${MEM_GB}GB)"
    else
        ARCH_RECOMMENDATION="Arch Linux (x86_64)"
    fi
elif [ "$ARCH" == "i686" ] || [ "$ARCH" == "i386" ]; then
    ARCH_RECOMMENDATION="Arch Linux 32"
elif [ "$ARCH" == "aarch64" ] || [ "$ARCH" == "arm64" ]; then
    ARCH_RECOMMENDATION="Arch Linux ARM (AArch64)"
elif [ "$ARCH" == "armv7l" ] || [ "$ARCH" == "armv7" ]; then
    ARCH_RECOMMENDATION="Arch Linux ARM (ARMv7)"
elif [ "$ARCH" == "armv6l" ] || [ "$ARCH" == "armv6" ]; then
    ARCH_RECOMMENDATION="Arch Linux ARM (ARMv6)"
else
    ARCH_RECOMMENDATION="Unknown architecture ($ARCH), please check https://archlinux.org/download/ for compatibility"
fi

# Special cases
if [ "$IS_VIRTUAL" = true ]; then
    ARCH_RECOMMENDATION="$ARCH_RECOMMENDATION - Consider using a minimal installation profile for virtual environments"
fi

if [ "$IS_UEFI" = true ]; then
    ARCH_RECOMMENDATION="$ARCH_RECOMMENDATION - Use UEFI boot mode"
else
    ARCH_RECOMMENDATION="$ARCH_RECOMMENDATION - Use Legacy/BIOS boot mode"
fi

# Print results
echo -e "\n======================="
echo "SYSTEM ANALYSIS RESULTS"
echo "======================="
echo "Architecture: $ARCH"
echo "CPU Type: $CPU_TYPE"
echo "Memory: ${MEM_GB}GB RAM"
echo "Boot Mode: $([ "$IS_UEFI" = true ] && echo "UEFI" || echo "Legacy BIOS")"
echo "Virtual Machine: $([ "$IS_VIRTUAL" = true ] && echo "Yes" || echo "No")"
echo ""
echo "RECOMMENDED ARCH LINUX VERSION:"
echo "--> $ARCH_RECOMMENDATION"
echo ""

# Print installation notes
echo "INSTALLATION NOTES:"

if [ "$CPU_TYPE" == "intel" ]; then
    echo "- Install intel-ucode package for CPU microcode updates"
elif [ "$CPU_TYPE" == "amd" ]; then
    echo "- Install amd-ucode package for CPU microcode updates"
fi

if echo "$GPU_INFO" | grep -q -i "nvidia"; then
    echo "- Consider installing the nvidia drivers (nvidia package)"
elif echo "$GPU_INFO" | grep -q -i "amd\|radeon"; then
    echo "- AMD GPU detected, consider installing mesa and xf86-video-amdgpu packages"
elif echo "$GPU_INFO" | grep -q -i "intel"; then
    echo "- Intel GPU detected, consider installing mesa and xf86-video-intel packages"
fi

if (( $(echo "$MEM_GB < 2" | bc -l) )); then
    echo "- Low RAM detected. Consider using a lightweight desktop environment like LXDE or a window manager like i3"
    echo "- Create a larger swap partition (at least equal to RAM size)"
elif (( $(echo "$MEM_GB < 4" | bc -l) )); then
    echo "- Moderate RAM detected. Consider using XFCE or MATE desktop environments"
fi

echo ""
echo "Visit https://archlinux.org/download/ to download your Arch Linux version"





### FILE: ./scripts/determine-arch-ver/README.md

# Determine Arch Linux Version

These scripts analyze your system and automatically recommend the appropriate Arch Linux version to install based on your hardware specifications.

## Available Scripts

- `linux-os-discovery.sh`: For users currently running Linux systems
- `windows-os-discovery.ps1`: For users currently running Windows systems

## For Linux Users

```bash
# Make the script executable
chmod +x linux-os-discovery.sh

# Run the script
./linux-os-discovery.sh
```

## For Windows Users

```powershell
# Open PowerShell as Administrator
# You may need to change execution policy
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process

# Run the script
.\windows-os-discovery.ps1
```

## What These Scripts Do

These scripts perform a comprehensive analysis of your system hardware and provide:

1. An immediate recommendation for which Arch Linux version to install
2. Custom installation notes specific to your hardware

### Information Analyzed

- **CPU Architecture**: x86_64, i686, ARM variants
- **CPU Type**: Intel, AMD, or ARM processors
- **Boot Mode**: UEFI vs Legacy BIOS
- **Memory**: Available RAM
- **Graphics**: GPU vendor (NVIDIA, AMD, Intel)
- **Virtualization**: If running in a virtual environment

## Arch Linux Version Selection Logic

The scripts use this system information to recommend:

1. **Standard Arch Linux (x86_64)**: For modern 64-bit Intel/AMD systems
2. **Arch Linux 32**: For legacy 32-bit systems or very low RAM systems
3. **Arch Linux ARM**: For various ARM architectures (aarch64, armv7, etc.)

### Additional Recommendations

- Boot mode specific instructions (UEFI vs Legacy)
- CPU microcode packages (intel-ucode or amd-ucode)
- GPU driver recommendations
- Desktop environment suggestions based on available RAM
- For Windows users: Dual-boot considerations and preparation steps

## Understanding System Requirements for Arch Linux

Based on the information collected, the scripts interpret:

1. **CPU Architecture**:
   - x86_64: Standard for most modern computers
   - i686: Legacy 32-bit architecture
   - ARM: For compatible devices like Raspberry Pi

2. **Boot Mode**:
   - UEFI: Modern boot method
   - Legacy BIOS: Older boot method

3. **Memory Requirements**:
   - Minimal: 512MB RAM (CLI only)
   - Desktop Environment: 1GB+ RAM
   - Modern desktop usage: 2GB+ recommended

## Next Steps

After receiving your Arch Linux version recommendation:

1. Download the appropriate Arch Linux ISO from [archlinux.org](https://archlinux.org/download/)
2. Create bootable media using tools like Rufus (Windows) or dd (Linux)
3. Boot from the installation media
4. Follow the Arch Linux installation guide, referring to your specific recommendations

## Troubleshooting

- **Permission denied**: Make sure to run with appropriate permissions (sudo for Linux, Administrator for Windows)
- **Execution policy errors**: On Windows, you may need to adjust PowerShell execution policy

## Contributing

Feel free to submit pull requests or suggest improvements to these scripts.





### FILE: ./scripts/determine-arch-ver/windows-os-discovery-updated.ps1

# Windows System Information Discovery Script
# Save this as Get-SystemInfo.ps1 and run in PowerShell

# Variables to track system specifications
$archType = ""
$isUEFI = $false
$totalMemoryGB = 0
$cpuType = ""
$gpuVendor = ""
$isVirtualized = $false

Write-Host "Analyzing system to determine appropriate Arch Linux version..."

# OS Information
$osInfo = Get-CimInstance Win32_OperatingSystem

# Determine architecture
if ($osInfo.OSArchitecture -match "64") {
    $archType = "x86_64"
} else {
    $archType = "i686"
}

# System Information
$compSystem = Get-CimInstance Win32_ComputerSystem

# Check for virtualization
if ($compSystem.Manufacturer -match "VMware|QEMU|VirtualBox|Xen|KVM|Parallels|Microsoft") {
    $isVirtualized = $true
}

# CPU Information
$processors = Get-CimInstance Win32_Processor
foreach ($cpu in $processors) {
    # Determine CPU type
    if ($cpu.Name -match "Intel") {
        $cpuType = "intel"
    } elseif ($cpu.Name -match "AMD") {
        $cpuType = "amd"
    } elseif ($cpu.Name -match "ARM") {
        $cpuType = "arm"
        $archType = "aarch64"
    }
}

# Memory Information
$totalMemoryGB = [math]::Round($compSystem.TotalPhysicalMemory / 1GB, 2)

# Graphics Information
$gpus = Get-CimInstance Win32_VideoController
foreach ($gpu in $gpus) {
    # Determine GPU vendor
    if ($gpu.Name -match "NVIDIA") {
        $gpuVendor = "nvidia"
    } elseif ($gpu.Name -match "AMD|ATI|Radeon") {
        $gpuVendor = "amd"
    } elseif ($gpu.Name -match "Intel") {
        $gpuVendor = "intel"
    }
}

# Check for UEFI
try {
    $uefiTest = Confirm-SecureBootUEFI -ErrorAction SilentlyContinue
    $isUEFI = $true
} catch {
    # If secure boot check fails, try an alternative method
    try {
        $regValue = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\SecureBoot\State" -Name UEFISecureBootEnabled -ErrorAction SilentlyContinue
        if ($regValue -ne $null) {
            $isUEFI = $true
        } else {
            $isUEFI = $false
        }
    } catch {
        # Default to checking firmware type
        if ($compSystem.BootupState -match "UEFI") {
            $isUEFI = $true
        } else {
            $isUEFI = $false
        }
    }
}

# Determine recommended Arch Linux version
$archRecommendation = "Unknown, please check compatibility"

# Determine based on architecture
if ($archType -eq "x86_64") {
    if ($totalMemoryGB -lt 1) {
        $archRecommendation = "Arch Linux 32 (due to low RAM: ${totalMemoryGB}GB)"
    } else {
        $archRecommendation = "Arch Linux (x86_64)"
    }
} elseif ($archType -eq "i686") {
    $archRecommendation = "Arch Linux 32"
} elseif ($archType -eq "aarch64") {
    $archRecommendation = "Arch Linux ARM (AArch64)"
}

# Special cases
if ($isVirtualized) {
    $archRecommendation = "$archRecommendation - Consider using a minimal installation profile for virtual environments"
}

if ($isUEFI) {
    $archRecommendation = "$archRecommendation - Use UEFI boot mode"
} else {
    $archRecommendation = "$archRecommendation - Use Legacy/BIOS boot mode"
}

# Print results
Write-Host "`n======================="
Write-Host "SYSTEM ANALYSIS RESULTS"
Write-Host "======================="
Write-Host "Architecture: $archType"
Write-Host "CPU Type: $cpuType"
Write-Host "Memory: ${totalMemoryGB}GB RAM"
Write-Host "Boot Mode: $(if ($isUEFI) {'UEFI'} else {'Legacy BIOS'})"
Write-Host "Virtual Machine: $(if ($isVirtualized) {'Yes'} else {'No'})"
Write-Host ""
Write-Host "RECOMMENDED ARCH LINUX VERSION:"
Write-Host "--> $archRecommendation"
Write-Host ""

# Print installation notes
Write-Host "INSTALLATION NOTES:"

if ($cpuType -eq "intel") {
    Write-Host "- Install intel-ucode package for CPU microcode updates"
} elseif ($cpuType -eq "amd") {
    Write-Host "- Install amd-ucode package for CPU microcode updates"
}

if ($gpuVendor -eq "nvidia") {
    Write-Host "- Consider installing the nvidia drivers (nvidia package)"
} elseif ($gpuVendor -eq "amd") {
    Write-Host "- AMD GPU detected, consider installing mesa and xf86-video-amdgpu packages"
} elseif ($gpuVendor -eq "intel") {
    Write-Host "- Intel GPU detected, consider installing mesa and xf86-video-intel packages"
}

if ($totalMemoryGB -lt 2) {
    Write-Host "- Low RAM detected. Consider using a lightweight desktop environment like LXDE or a window manager like i3"
    Write-Host "- Create a larger swap partition (at least equal to RAM size)"
} elseif ($totalMemoryGB -lt 4) {
    Write-Host "- Moderate RAM detected. Consider using XFCE or MATE desktop environments"
}

# Windows-specific notes
Write-Host "- Consider using dual boot instead of replacing Windows completely"
Write-Host "- Make sure to disable Fast Startup and Hibernation in Windows before installing"
Write-Host "- Back up important data before installation"

if ($isUEFI) {
    Write-Host "- Disable Secure Boot in UEFI before installing Arch Linux"
    Write-Host "- Consider creating a separate EFI partition (550MB) if not already present"
}

Write-Host "`nVisit https://archlinux.org/download/ to download your Arch Linux version"





### FILE: ./scripts/install/arch-install-script.sh

#!/bin/bash

# Arch Linux Development Environment Installation Script
# This script automates the installation of Arch Linux with KDE Plasma and development tools

# Color codes for better readability
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Log file
LOG_FILE="/tmp/arch_install.log"

# Function to log messages
log() {
    local message="$1"
    local level="${2:-INFO}"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    echo -e "${timestamp} [${level}] ${message}" | tee -a "$LOG_FILE"
}

# Function to display error messages and exit
error_exit() {
    log "$1" "ERROR"
    exit 1
}

# Function to check if command executed successfully
check_success() {
    if [ $? -ne 0 ]; then
        error_exit "$1"
    fi
}

# Function to display section headers
section() {
    echo -e "\n${BLUE}=== $1 ===${NC}"
    log "Starting section: $1" "SECTION"
}

# Function to confirm action
confirm() {
    while true; do
        read -p "$1 (y/n): " yn
        case $yn in
            [Yy]* ) return 0;;
            [Nn]* ) return 1;;
            * ) echo "Please answer y or n.";;
        esac
    done
}

# Check if script is run as root
if [ "$(id -u)" -ne 0 ]; then
    error_exit "This script must be run as root"
fi

# Check if running in Arch Linux live environment
if ! grep -q "Arch Linux" /etc/os-release; then
    error_exit "This script must be run in an Arch Linux live environment"
fi

# Display welcome message
clear
echo -e "${GREEN}Welcome to the Arch Linux Development Environment Installation Script${NC}"
echo -e "This script will install and configure Arch Linux with the following components:"
echo -e "- KDE Plasma desktop environment"
echo -e "- Development tools (Python, IntelliJ, Neovim, etc.)"
echo -e "- Browsers and Office applications"
echo -e "- Gaming software (Steam, Lutris)"
echo -e "- Various utilities and tools"
echo
echo -e "${YELLOW}IMPORTANT: This script will format the selected disk. Make sure you have backups of important data.${NC}"
echo

# Confirm installation
if ! confirm "Do you want to proceed with the installation?"; then
    echo "Installation aborted."
    exit 0
fi

# Function to check and setup network connection
setup_network() {
    section "Network Setup"
    
    # Check if network is available
    if ping -c 1 archlinux.org > /dev/null 2>&1; then
        log "Network is already configured and working"
        return 0
    fi
    
    log "Network not available, attempting to configure..."
    
    # Ask user for network configuration method
    echo "Network connection methods:"
    echo "1) Wired (DHCP)"
    echo "2) Wireless (Wi-Fi)"
    read -p "Select network connection method (1-2): " network_choice
    
    case $network_choice in
        1)
            log "Setting up wired connection with DHCP"
            dhcpcd
            check_success "Failed to configure wired network connection"
            ;;
        2)
            log "Setting up wireless connection"
            iwctl
            check_success "Failed to configure wireless network connection"
            ;;
        *)
            error_exit "Invalid network connection method selected"
            ;;
    esac
    
    # Verify network connection
    if ! ping -c 1 archlinux.org > /dev/null 2>&1; then
        error_exit "Network configuration failed. Please configure network manually and restart the script."
    fi
    
    log "Network configured successfully"
}

# Function to setup disk partitioning
setup_disk() {
    section "Disk Setup"
    
    # List available disks
    echo "Available disks:"
    lsblk -pdo NAME,SIZE,MODEL
    
    # Ask user for target disk
    read -p "Enter the disk to install Arch Linux (e.g., /dev/sda): " target_disk
    
    # Verify disk exists
    if [ ! -b "$target_disk" ]; then
        error_exit "Invalid disk: $target_disk"
    fi
    
    echo -e "${RED}WARNING: All data on $target_disk will be erased!${NC}"
    if ! confirm "Are you sure you want to continue?"; then
        error_exit "Disk setup aborted."
    fi
    
    # Ask about partitioning scheme
    echo "Partitioning schemes:"
    echo "1) UEFI with GPT (recommended for modern systems)"
    echo "2) BIOS with MBR (for legacy systems)"
    read -p "Select partitioning scheme (1-2): " part_scheme
    
    # Ask for swap size
    read -p "Enter swap size in GB (recommended: RAM size if < 8GB, 8GB if RAM > 8GB): " swap_size
    
    # Create partitions based on chosen scheme
    if [ "$part_scheme" -eq 1 ]; then
        log "Creating UEFI/GPT partitions"
        
        # Wipe disk
        wipefs -a "$target_disk"
        check_success "Failed to wipe disk"
        
        # Create GPT partition table
        parted -s "$target_disk" mklabel gpt
        check_success "Failed to create GPT partition table"
        
        # Create EFI partition (550MB)
        parted -s "$target_disk" mkpart "EFI" fat32 1MiB 551MiB
        parted -s "$target_disk" set 1 esp on
        
        # Create swap partition
        parted -s "$target_disk" mkpart "swap" linux-swap 551MiB "$((551 + ($swap_size * 1024)))MiB"
        
        # Create root partition (rest of disk)
        parted -s "$target_disk" mkpart "root" ext4 "$((551 + ($swap_size * 1024)))MiB" 100%
        
        # Get partition names
        if [[ "$target_disk" == *"nvme"* ]]; then
            efi_part="${target_disk}p1"
            swap_part="${target_disk}p2"
            root_part="${target_disk}p3"
        else
            efi_part="${target_disk}1"
            swap_part="${target_disk}2"
            root_part="${target_disk}3"
        fi
        
        # Format partitions
        log "Formatting partitions"
        mkfs.fat -F32 "$efi_part"
        check_success "Failed to format EFI partition"
        
        mkswap "$swap_part"
        check_success "Failed to create swap"
        swapon "$swap_part"
        
        mkfs.ext4 -F "$root_part"
        check_success "Failed to format root partition"
        
        # Mount partitions
        log "Mounting partitions"
        mount "$root_part" /mnt
        check_success "Failed to mount root partition"
        
        mkdir -p /mnt/boot/efi
        mount "$efi_part" /mnt/boot/efi
        check_success "Failed to mount EFI partition"
        
    elif [ "$part_scheme" -eq 2 ]; then
        log "Creating BIOS/MBR partitions"
        
        # Wipe disk
        wipefs -a "$target_disk"
        check_success "Failed to wipe disk"
        
        # Create MBR partition table
        parted -s "$target_disk" mklabel msdos
        check_success "Failed to create MBR partition table"
        
        # Create swap partition
        parted -s "$target_disk" mkpart primary linux-swap 1MiB "$((1 + ($swap_size * 1024)))MiB"
        
        # Create root partition (rest of disk)
        parted -s "$target_disk" mkpart primary ext4 "$((1 + ($swap_size * 1024)))MiB" 100%
        parted -s "$target_disk" set 2 boot on
        
        # Get partition names
        if [[ "$target_disk" == *"nvme"* ]]; then
            swap_part="${target_disk}p1"
            root_part="${target_disk}p2"
        else
            swap_part="${target_disk}1"
            root_part="${target_disk}2"
        fi
        
        # Format partitions
        log "Formatting partitions"
        mkswap "$swap_part"
        check_success "Failed to create swap"
        swapon "$swap_part"
        
        mkfs.ext4 -F "$root_part"
        check_success "Failed to format root partition"
        
        # Mount partitions
        log "Mounting partitions"
        mount "$root_part" /mnt
        check_success "Failed to mount root partition"
    else
        error_exit "Invalid partitioning scheme selected"
    fi
    
    log "Disk partitioning completed successfully"
}

# Function to install base system
install_base() {
    section "Installing Base System"
    
    # Update mirror list
    log "Updating mirror list"
    pacman -Sy --noconfirm reflector
    reflector --latest 20 --sort rate --save /etc/pacman.d/mirrorlist
    check_success "Failed to update mirror list"
    
    # Install base packages
    log "Installing base packages"
    pacstrap /mnt base base-devel linux linux-firmware \
             vim nano sudo networkmanager dhcpcd dialog wpa_supplicant \
             intel-ucode amd-ucode dosfstools
    check_success "Failed to install base packages"
    
    # Generate fstab
    log "Generating fstab"
    genfstab -U /mnt >> /mnt/etc/fstab
    check_success "Failed to generate fstab"
    
    log "Base system installation completed"
}

# Function to configure the base system
configure_base() {
    section "Configuring Base System"
    
    # Set timezone
    log "Setting timezone"
    read -p "Enter your timezone (e.g., America/New_York): " timezone
    arch-chroot /mnt ln -sf "/usr/share/zoneinfo/$timezone" /etc/localtime
    arch-chroot /mnt hwclock --systohc
    
    # Configure locale
    log "Configuring locale"
    echo "en_US.UTF-8 UTF-8" > /mnt/etc/locale.gen
    arch-chroot /mnt locale-gen
    echo "LANG=en_US.UTF-8" > /mnt/etc/locale.conf
    
    # Set hostname
    log "Setting hostname"
    read -p "Enter hostname: " hostname
    echo "$hostname" > /mnt/etc/hostname
    
    # Configure hosts file
    cat > /mnt/etc/hosts << EOF
127.0.0.1   localhost
::1         localhost
127.0.1.1   $hostname.localdomain   $hostname
EOF
    
    # Set root password
    log "Setting root password"
    echo "Please set the root password:"
    arch-chroot /mnt passwd
    
    # Create user
    log "Creating user"
    read -p "Enter username: " username
    arch-chroot /mnt useradd -m -G wheel,storage,power,video,audio -s /bin/bash "$username"
    echo "Please set the password for $username:"
    arch-chroot /mnt passwd "$username"
    
    # Configure sudo
    log "Configuring sudo"
    sed -i '/%wheel ALL=(ALL) ALL/s/^# //' /mnt/etc/sudoers
    
    # Enable NetworkManager
    log "Enabling NetworkManager"
    arch-chroot /mnt systemctl enable NetworkManager
    
    log "Base system configuration completed"
}

# Function to install and configure bootloader
install_bootloader() {
    section "Installing Bootloader"
    
    if [ -d "/mnt/boot/efi" ]; then
        # UEFI system
        log "Installing GRUB for UEFI"
        arch-chroot /mnt pacman -S --noconfirm grub efibootmgr
        arch-chroot /mnt grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB
    else
        # BIOS system
        log "Installing GRUB for BIOS"
        read -p "Enter the disk to install GRUB (e.g., /dev/sda): " grub_disk
        arch-chroot /mnt pacman -S --noconfirm grub
        arch-chroot /mnt grub-install --target=i386-pc "$grub_disk"
    fi
    
    # Configure GRUB
    log "Configuring GRUB"
    arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg
    check_success "Failed to configure GRUB"
    
    log "Bootloader installation completed"
}

# Function to install KDE Plasma desktop environment
install_kde() {
    section "Installing KDE Plasma"
    
    # Install X.org server
    log "Installing X.org server"
    arch-chroot /mnt pacman -S --noconfirm xorg xorg-server
    
    # Install KDE Plasma
    log "Installing KDE Plasma desktop environment"
    arch-chroot /mnt pacman -S --noconfirm plasma-meta kde-applications
    
    # Install SDDM display manager
    log "Installing SDDM display manager"
    arch-chroot /mnt pacman -S --noconfirm sddm
    arch-chroot /mnt systemctl enable sddm
    
    # Install additional useful KDE apps
    log "Installing additional KDE applications"
    arch-chroot /mnt pacman -S --noconfirm \
        dolphin konsole kate ark kfind \
        kcalc spectacle okular gwenview
    
    log "KDE Plasma installation completed"
}

# Function to install AUR helper (yay)
install_aur_helper() {
    section "Installing AUR Helper (yay)"
    
    # Install Git
    arch-chroot /mnt pacman -S --noconfirm git
    
    # Clone and build yay
    arch-chroot /mnt bash -c "cd /home/$username && sudo -u $username git clone https://aur.archlinux.org/yay.git"
    arch-chroot /mnt bash -c "cd /home/$username/yay && sudo -u $username makepkg -si --noconfirm"
    arch-chroot /mnt rm -rf "/home/$username/yay"
    
    log "AUR helper installation completed"
}

# Function to install development tools
install_dev_tools() {
    section "Installing Development Tools"
    
    # Install Python and related tools
    log "Installing Python and related tools"
    arch-chroot /mnt pacman -S --noconfirm python python-pip python-setuptools python-wheel
    
    # Install Poetry and uv for Python package management
    log "Installing Poetry and uv for Python package management"
    arch-chroot /mnt bash -c "sudo -u $username yay -S --noconfirm python-poetry"
    arch-chroot /mnt bash -c "sudo -u $username pip install uv"
    
    # Install Neovim and dependencies
    log "Installing Neovim"
    arch-chroot /mnt pacman -S --noconfirm neovim python-pynvim nodejs npm ripgrep fd
    
    # Install IntelliJ Community Edition
    log "Installing IntelliJ Community Edition"
    arch-chroot /mnt pacman -S --noconfirm intellij-idea-community-edition
    
    # Install development libraries and tools
    log "Installing development libraries and tools"
    arch-chroot /mnt pacman -S --noconfirm \
        base-devel git cmake gcc clang gdb \
        jdk-openjdk maven gradle \
        docker docker-compose \
        sqlite mariadb \
        curl wget htop
    
    # Enable Docker service
    arch-chroot /mnt systemctl enable docker.service
    
    log "Development tools installation completed"
}

# Function to install Oh My Zsh and Starship
install_shell_tools() {
    section "Installing Shell Tools"
    
    # Install Zsh
    log "Installing Zsh"
    arch-chroot /mnt pacman -S --noconfirm zsh
    
    # Install Oh My Zsh
    log "Installing Oh My Zsh"
    arch-chroot /mnt bash -c "cd /home/$username && sudo -u $username sh -c \"\$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" '' --unattended"
    
    # Change default shell to Zsh
    arch-chroot /mnt chsh -s /bin/zsh "$username"
    
    # Install Starship prompt
    log "Installing Starship prompt"
    arch-chroot /mnt bash -c "cd /home/$username && sudo -u $username curl -sS https://starship.rs/install.sh | sh -s -- -y"
    
    # Configure Starship
    mkdir -p /mnt/home/$username/.config
    cat > /mnt/home/$username/.config/starship.toml << 'EOF'
# Starship configuration
format = """
[](#9A348E)\
$username\
[](bg:#DA627D fg:#9A348E)\
$directory\
[](fg:#DA627D bg:#FCA17D)\
$git_branch\
$git_status\
[](fg:#FCA17D bg:#86BBD8)\
$python\
$rust\
$golang\
$nodejs\
[](fg:#86BBD8 bg:#06969A)\
$docker_context\
[](fg:#06969A bg:#33658A)\
$time\
[ ](fg:#33658A)\
"""

# Disable the blank line at the start of the prompt
add_newline = false

[username]
show_always = true
style_user = "bg:#9A348E fg:#FFFFFF"
style_root = "bg:#9A348E fg:#FFFFFF"
format = '[$user ]($style)'

[directory]
style = "bg:#DA627D fg:#FFFFFF"
format = "[ $path ]($style)"
truncation_length = 3
truncation_symbol = "…/"

[git_branch]
symbol = ""
style = "bg:#FCA17D fg:#000000"
format = '[ $symbol $branch ]($style)'

[git_status]
style = "bg:#FCA17D fg:#000000"
format = '[$all_status$ahead_behind ]($style)'

[python]
symbol = " "
style = "bg:#86BBD8 fg:#000000"
format = '[ $symbol ($version) ]($style)'

[rust]
symbol = " "
style = "bg:#86BBD8 fg:#000000"
format = '[ $symbol ($version) ]($style)'

[golang]
symbol = " "
style = "bg:#86BBD8 fg:#000000"
format = '[ $symbol ($version) ]($style)'

[nodejs]
symbol = " "
style = "bg:#86BBD8 fg:#000000"
format = '[ $symbol ($version) ]($style)'

[docker_context]
symbol = " "
style = "bg:#06969A fg:#FFFFFF"
format = '[ $symbol $context ]($style)'

[time]
disabled = false
time_format = "%R" # Hour:Minute Format
style = "bg:#33658A fg:#FFFFFF"
format = '[ $time ]($style)'
EOF
    
    # Set proper permissions
    arch-chroot /mnt chown -R "$username:$username" "/home/$username/.config"
    
    # Configure .zshrc to use Starship
    echo 'eval "$(starship init zsh)"' >> /mnt/home/$username/.zshrc
    
    # Install Ghostty terminal (if available in AUR)
    log "Installing Ghostty terminal"
    arch-chroot /mnt bash -c "sudo -u $username yay -S --noconfirm ghostty || echo 'Ghostty not found in AUR, skipping...'"
    
    log "Shell tools installation completed"
}

# Function to install browsers and office applications
install_browsers_office() {
    section "Installing Browsers and Office Applications"
    
    # Install Brave Browser
    log "Installing Brave Browser"
    arch-chroot /mnt bash -c "sudo -u $username yay -S --noconfirm brave-bin"
    
    # Install LibreOffice
    log "Installing LibreOffice"
    arch-chroot /mnt pacman -S --noconfirm libreoffice-fresh libreoffice-fresh-en-us
    
    log "Browsers and office applications installation completed"
}

# Function to install utilities
install_utilities() {
    section "Installing Utilities"
    
    # Install Ark (zip manager)
    log "Installing Ark (zip manager)"
    arch-chroot /mnt pacman -S --noconfirm ark p7zip unrar unzip zip
    
    # Install network tools
    log "Installing network tools"
    arch-chroot /mnt pacman -S --noconfirm \
        net-tools inetutils dnsutils traceroute \
        nmap wireshark-qt ethtool iperf3
    
    # Install Obsidian
    log "Installing Obsidian"
    arch-chroot /mnt bash -c "sudo -u $username yay -S --noconfirm obsidian"
    
    # Install Bitwarden
    log "Installing Bitwarden"
    arch-chroot /mnt bash -c "sudo -u $username yay -S --noconfirm bitwarden-bin"
    
    # Install Cider (Apple Music client)
    log "Installing Cider (Apple Music client)"
    arch-chroot /mnt bash -c "sudo -u $username yay -S --noconfirm cider"
    
    log "Utilities installation completed"
}

# Function to install gaming software
install_gaming() {
    section "Installing Gaming Software"
    
    # Enable multilib repository
    if ! grep -q "^\[multilib\]" /mnt/etc/pacman.conf; then
        log "Enabling multilib repository"
        cat >> /mnt/etc/pacman.conf << EOF

[multilib]
Include = /etc/pacman.d/mirrorlist
EOF
        arch-chroot /mnt pacman -Sy
    fi
    
    # Install Steam
    log "Installing Steam"
    arch-chroot /mnt pacman -S --noconfirm steam
    
    # Install Lutris
    log "Installing Lutris"
    arch-chroot /mnt pacman -S --noconfirm lutris wine-staging giflib lib32-giflib libpng lib32-libpng libldap lib32-libldap gnutls lib32-gnutls mpg123 lib32-mpg123 openal lib32-openal v4l-utils lib32-v4l-utils libpulse lib32-libpulse libgpg-error lib32-libgpg-error alsa-plugins lib32-alsa-plugins alsa-lib lib32-alsa-lib libjpeg-turbo lib32-libjpeg-turbo sqlite lib32-sqlite libxcomposite lib32-libxcomposite libxinerama lib32-libxinerama ncurses lib32-ncurses opencl-icd-loader lib32-opencl-icd-loader libxslt lib32-libxslt libva lib32-libva gtk3 lib32-gtk3 gst-plugins-base-libs lib32-gst-plugins-base-libs vulkan-icd-loader lib32-vulkan-icd-loader
    
    log "Gaming software installation completed"
}

# Function to install optional components
install_optional() {
    section "Installing Optional Components"
    
    # Ask about YubiKey setup
    if confirm "Do you want to install YubiKey support?"; then
        log "Installing YubiKey support"
        arch-chroot /mnt pacman -S --noconfirm \
            yubikey-personalization yubikey-manager \
            libusb-compat pam-u2f
        
        # Create udev rules for YubiKey
        cat > /mnt/etc/udev/rules.d/70-yubikey.rules << EOF
# Udev rules for YubiKey
ACTION=="add|change", SUBSYSTEM=="usb", ATTRS{idVendor}=="1050", ATTRS{idProduct}=="0113|0114|0115|0116|0120|0200|0402|0403|0406|0407|0410", TAG+="uaccess"
EOF
        
        # Reload udev rules
        arch-chroot /mnt udevadm control --reload-rules
        arch-chroot /mnt udevadm trigger
    fi
    
    # Ask about Podman setup
    if confirm "Do you want to install Podman with Docker compatibility?"; then
        log "Installing Podman with Docker compatibility"
        
        # Install Podman
        arch-chroot /mnt pacman -S --noconfirm podman podman-docker podman-compose
        
        # Create Docker compatibility alias
        cat >> /mnt/home/$username/.zshrc << EOF

# Docker compatibility for Podman
alias docker=podman
alias docker-compose=podman-compose
EOF
        
        # Set proper permissions
        arch-chroot /mnt chown "$username:$username" "/home/$username/.zshrc"
    fi
    
    log "Optional components installation completed"
}

# Function to perform final configurations
final_config() {
    section "Performing Final Configurations"
    
    # Enable services
    log "Enabling essential services"
    arch-chroot /mnt systemctl enable NetworkManager.service
    
    # Update the system
    log "Updating the system"
    arch-chroot /mnt pacman -Syu --noconfirm
    
    # Clean up
    log "Cleaning up"
    arch-chroot /mnt pacman -Sc --noconfirm
    
    log "Final configurations completed"
}

# Main installation flow
main() {
    # Start logging
    echo "" > "$LOG_FILE"
    log "Starting Arch Linux Development Environment Installation"
    
    # Setup steps
    setup_network
    setup_disk
    install_base
    configure_base
    install_bootloader
    install_kde
    install_aur_helper
    install_dev_tools
    install_shell_tools
    install_browsers_office
    install_utilities
    install_gaming
    install_optional
    final_config
    
    # Installation completed
    section "Installation Completed"
    log "Arch Linux development environment has been successfully installed!"
    
    # Unmount partitions
    umount -R /mnt
    
    echo -e "${GREEN}Installation completed successfully!${NC}"
    echo -e "You can now reboot your system and log in to your new Arch Linux installation."
    echo -e "Log file is available at: $LOG_FILE"
    
    if confirm "Do you want to reboot now?"; then
        reboot
    fi
}

# Run main function
main





### FILE: ./scripts/setup-root-ca/root-ca-setup.sh

#!/bin/bash

set -e # Exit on error

# Function to test signing and verification with retry
test_signing() {
  local sign_token="$1"
  local attempts=0
  local max_attempts=3

  echo "📄 Creating test file for signing..."
  echo "YubiKey signing test" >testfile.txt

  while [[ $attempts -lt $max_attempts ]]; do
    echo "🔏 Signing the test file (Attempt $((attempts + 1))/$max_attempts)..."

    if openssl dgst -sha256 -engine pkcs11 -keyform engine \
      -sign "pkcs11:token=${sign_token};object=PIV AUTH key" \
      -out testfile.sig testfile.txt; then
      echo "✅ File signed successfully!"
      break
    else
      echo "❌ Signing failed! Retrying..."
      attempts=$((attempts + 1))
      sleep 2
    fi
  done

  if [[ $attempts -ge $max_attempts ]]; then
    echo "❌ Signing failed after $max_attempts attempts. Exiting."
    exit 1
  fi

  echo "🔍 Verifying signature..."
  openssl x509 -in "$ROOT_CERT" -noout -subject -issuer
  openssl dgst -sha256 -engine pkcs11 -keyform engine \
    -verify "pkcs11:token=${sign_token};object=PIV AUTH pubkey" \
    -signature testfile.sig testfile.txt && echo "✅ Signature verified!" || echo "❌ Signature verification failed!"

  echo "📜 Signature Output:"
  cat testfile.sig | base64

  echo "🔎 Certificate Information:"
  openssl x509 -in "$ROOT_CERT" -text -noout | grep -E 'Issuer:|Subject:'
}

# Prompt for server name
read -p "Enter the server name (e.g., cosmic-garden.home): " SERVER_NAME

# Set file names
ROOT_KEY="root_ca_key.pem"
ROOT_CSR="root_ca.csr"
ROOT_CERT="root_ca.crt"
SERVER_KEY="${SERVER_NAME}_key.pem"
SERVER_CSR="${SERVER_NAME}.csr"
SERVER_CERT="${SERVER_NAME}.crt"

# Set the YubiKey PIV slot (9A for authentication)
SLOT="9a"

# Set PKCS11 module path
export PKCS11_MODULE="/usr/lib64/pkcs11/opensc-pkcs11.so"

# Function to ensure YubiKey is inserted
wait_for_yubikey() {
  while ! ykman piv info &>/dev/null; do
    echo -e "⏳ Waiting for YubiKey to be inserted..."
    sleep 2
  done
}

# Function to prompt user for YubiKey swap (only prompts twice)
prompt_swap() {
  if [[ "$SWAP_COUNT" -ge 1 ]]; then
    return
  fi
  SWAP_COUNT=$((SWAP_COUNT + 1))
  echo -e "\n🔄 Swap YubiKeys now and press [Enter] when ready..."
  read -r
  wait_for_yubikey
}

# Ensure required tools are installed
if ! command -v ykman &>/dev/null || ! command -v openssl &>/dev/null; then
  echo "❌ Error: 'ykman' or 'openssl' not found. Install them first."
  exit 1
fi

SWAP_COUNT=0
echo "🚀 Starting YubiKey backup process..."
wait_for_yubikey

# Generate and sign certificates
echo "🔑 Generating Root CA key and CSR..."
openssl ecparam -genkey -name prime256v1 -out "$ROOT_KEY"
openssl req -new -key "$ROOT_KEY" -out "$ROOT_CSR" -subj "/CN=$SERVER_NAME"

echo "📜 Signing Root CA certificate..."
openssl x509 -req -in "$ROOT_CSR" -signkey "$ROOT_KEY" -out "$ROOT_CERT" -days 3650 -sha256

echo "🔑 Generating Server Key and CSR..."
openssl ecparam -genkey -name prime256v1 -out "$SERVER_KEY"
openssl req -new -key "$SERVER_KEY" -out "$SERVER_CSR" -subj "/CN=$SERVER_NAME"

echo "📜 Signing Server Certificate..."
openssl x509 -req -in "$SERVER_CSR" -CA "$ROOT_CERT" -CAkey "$ROOT_KEY" -CAcreateserial -out "$SERVER_CERT" -days 730 -sha256

echo -e "\n🔐 Insert your PRIMARY YubiKey and press [Enter]..."
read -r
wait_for_yubikey

echo "⬆️ Importing Root CA private key to PRIMARY YubiKey..."
ykman piv keys import "$SLOT" "$ROOT_KEY"
ykman piv certificates import "$SLOT" "$ROOT_CERT"

test_signing "Root CA"

prompt_swap

echo "⬆️ Importing Root CA private key to BACKUP YubiKey..."
ykman piv keys import "$SLOT" "$ROOT_KEY"
ykman piv certificates import "$SLOT" "$ROOT_CERT"

test_signing "Root CA"

echo "🧹 Securely deleting local private key files..."
shred -u "$ROOT_KEY" "$SERVER_KEY"
rm -f "$ROOT_CSR" "$SERVER_CSR"

echo "🎉 All done! Both YubiKeys have been successfully backed up and validated."



